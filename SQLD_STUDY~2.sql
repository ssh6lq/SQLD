--4일차

-- JOIN
--등가조인, 비등가 조인
--등가조인 : A:B
--비등가조인 : >,<,>=,<=,!= , BETWEEN...

SELECT * FROM EMP;
SELECT *FROM DEPT;
--2개의 테이블 FK키 연결하려고 함

SELECT *FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO; --등가조인

SELECT SAL, SAL FROM EMP;

SELECT EMPNO, ENAME, SAL, DEPT.DEPTNO, DNAME, LOC
FROM EMP, DEPT
WHERE EMP.DEPTNO=DEPT.DEPTNO; --(X)DEPTNO가 문제

SELECT EMP.EMPNO, EMP.ENAME, EMP.SAL, DEPT.DEPTNO, DEPT.DNAME, DEPT.LOC
FROM EMP, DEPT
WHERE EMP.DEPTNO=DEPT.DEPTNO;

--테이블 명이 길다면 별칭 붙이기
SELECT E.EMPNO, E.ENAME, E.SAL, D.DEPTNO, D.DNAME, D.LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO=D.DEPTNO;

SELECT E.EMPNO, D.DNAME
FROM EMP E, DEPT D --FROM에서 이름 바꿨으면 바뀐 이름대로 적용해야함
WHERE E.DEPTNO=D.DEPTNO;

SELECT E.EMPNO, E.ENAME, E.SAL S, D.DEPTNO, D.DNAME, D.LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO=D.DEPTNO
ORDER BY S;

--비등가조인
SELECT *FROM EMP;
SELECT *FROM SALGRADE;

SELECT ENAME, EMPNO, SAL, 
CASE 
     WHEN SAL>= 700 AND SAL<=1200 THEN '1등급'
     WHEN SAL>= 1201 AND SAL<=1400 THEN '2등급'
     WHEN SAL>= 1401 AND SAL<=2000 THEN '3등급'
     WHEN SAL>= 2001 AND SAL<=3000 THEN '4등급'
     ELSE '5등급'
END 급여등급
FROM EMP;

SELECT * 
FROM EMP, SALGRADE;

SELECT *
FROM EMP, SALGRADE
WHERE EMP.SAL>SALGRADE.LOSAL AND EMP.SAL<=SALGRADE.HISAL; --비등가조인

SELECT *
FROM EMP, SALGRADE
WHERE EMP.SAL BETWEEN SALGRADE.LOSAL AND SALGRADE.HISAL;

SELECT E.EMPNO, E.SAL, S.GRADE
FROM EMP E, SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL;

--EMP, DEPT, SALGRADE 
SELECT *
FROM EMP, DEPT, SALGRADE;

SELECT*
FROM EMP E, DEPT D, SALGRADE S
WHERE E.DEPTNO=D.DEPTNO
AND E.SAL BETWEEN S.LOSAL AND S.HISAL;

SELECT*
FROM EMP E, DEPT D, SALGRADE S
WHERE E.DEPTNO=D.DEPTNO
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL; --WHERE 2개 사용은 실행 안됨

--1),+WHERE
--2)<INNER> JOIN + ON 조건절
--3)<INNER>JOIN + USING(공통컬럼명)

SELECT *
FROM EMP E, DEPT D
WHERE E.DEPTNO=D.DEPTNO;

SELECT *
FROM EMP E INNER JOIN DEPT D
ON E.DEPTNO=D.DEPTNO;

SELECT *
FROM EMP E JOIN DEPT D
ON E.DEPTNO=D.DEPTNO; --INNER JOIN 생략 가능

--USING은 공통 컬럼명만 넣어주면 됨.
-- 두 테이블의 JOIN조건절의 컬럼명이 다르면 사용 불가
--등가조인에서만 사용, 비 등가조인에서는 사용불가
SELECT * 
FROM EMP E JOIN DEPT D
USING (DEPTNO); --공통 컬럼명만 넣어주면 됨

SELECT * 
FROM EMP E JOIN DEPT D
USING (E.DEPTNO = D.DEPTNO);  --(X)

SELECT E.EMPNO, E.ENAME, D.DEPTNO, D.LOC
FROM EMP E INNER JOIN DEPT D
ON E.DEPTNO=D.DEPTNO;

SELECT E.EMPNO, E.ENAME, DEPTNO, D.LOC --USING열은 식별자 구분 필요없음
FROM EMP E JOIN DEPT D
USING(DEPTNO);

--EMP, DEPT 테이블에서 DEPTNO가 30인 부서에 속하는 사원의 ENAME, DEPTNO, DNAME
SELECT E.ENAME, D.DEPTNO, D.DNAME
FROM EMP E INNER JOIN DEPT D
ON E.DEPTNO = E.DEPTNO
WHERE D.DEPTNO = 30; --WHERE와 ON이 비슷한 역할로 바로 AND 사용해도됨.

SELECT E.ENAME, E.DEPTNO, D.DNAME
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
AND D.DEPTNO = 30;

SELECT E.ENAME, DEPTNO, D.DNAME
FROM EMP E JOIN DEPT D
USING(DEPTNO)
WHERE DEPTNO=30;

--비등가조인
SELECT *
FROM EMP, SALGRADE
WHERE EMP.SAL>=SALGRADE.LOSAL AND EMP.SAL<=SALGRADE.HISAL;

SELECT *
FROM EMP JOIN SALGRADE
ON E.DEPTNO=D.DEPTNO; --(X)

SELECT *
FROM EMP JOIN SALGRADE
USING(EMP.SAL>=SALGRADE.LOSAL AND EMP.SAL<=SALGRADE.HISAL); --(X) USING은 비등가조인에서 사용 불가

--급여가 4등급인 사원들의
--EMPNO, ENAME, SAL, DNAME, LOC
SELECT *
FROM EMP, DEPT, SALGRADE;

SELECT E.EMPNO, E.ENAME, E.SAL, D.DNAME, D.LOC, S.GRADE
FROM EMP E, DEPT D, SALGRADE S
WHERE E.DEPTNO = D.DEPTNO --등가조인
AND E.SAL BETWEEN S.LOSAL AND S.HISAL --비등가조인
AND S.GRADE = 4;

SELECT E.EMPNO, E.ENAME, E.SAL, D.DNAME, D.LOC, S.GRADE
FROM EMP E JOIN DEPT D JOIN SALGRADE S --조인은 이렇게 연달아서 연결하면 안됨
ON E.DEPTNO = D.DEPTNO
AND E.SAL BETWEEN S.LOSAL AND S.HISAL
AND S.GRADE = 4;  --(X)

SELECT E.EMPNO, E.ENAME, E.SAL, D.DNAME, D.LOC, S.GRADE
FROM EMP E JOIN DEPT D
ON E.DEPTNO = D.DEPTNO
JOIN SALGRADE S
ON E.SAL BETWEEN S.LOSAL AND S.HISAL
WHERE S.GRADE = 4; 

SELECT E.EMPNO, E.ENAME, E.SAL, D.DNAME, D.LOC, S.GRADE
FROM EMP E JOIN DEPT D
ON E.DEPTNO = D.DEPTNO
JOIN SALGRADE S
ON E.SAL BETWEEN S.LOSAL AND S.HISAL
AND S.GRADE = 4; 

SELECT E.EMPNO, E.ENAME, E.SAL, D.DNAME, D.LOC, S.GRADE
FROM 
    EMP E JOIN DEPT D
    USING(DEPTNO)
    JOIN SALGRADE S
    ON E.SAL BETWEEN S.LOSAL AND S.HISAL
WHERE S.GRADE = 4; 

SELECT E.EMPNO, E.ENAME, E.SAL, D.DNAME, D.LOC, S.GRADE
FROM EMP E JOIN DEPT D
WHERE E.DEPTNO = D.DEPTNO --(X)
JOIN SALGRADE S
ON E.SAL BETWEEN S.LOSAL AND S.HISAL
WHERE S.GRADE = 4; 

SELECT E.EMPNO, E.ENAME, E.SAL, D.DNAME, D.LOC, S.GRADE
FROM EMP E JOIN DEPT D
WHERE E.DEPTNO = D.DEPTNO;--WHERE 2개 사용불가
JOIN SALGRADE S
ON E.SAL BETWEEN S.LOSAL AND S.HISAL
WHERE S.GRADE = 4; 

SELECT E.EMPNO, E.ENAME, E.SAL, D.DNAME, D.LOC, S.GRADE
FROM 
    EMP E JOIN DEPT D
    ON E.DEPTNO=D.DEPTNO
    , SALGRADE S --콤마로 연결 가능
    WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL
AND S.GRADE = 4; 

SELECT E.EMPNO, E.ENAME, E.SAL, D.DNAME, D.LOC, S.GRADE
FROM 
    EMP E JOIN DEPT D
    WHERE E.DEPTNO=D.DEPTNO
    JOIN SALGRADE S --콤마로 연결 가능
    ON E.SAL BETWEEN S.LOSAL AND S.HISAL
AND S.GRADE = 4; -- 위에 WHERE쓰면 밑에 까지 다 WHERE절이 됨 (X)

-- 각 급여 등급별 급여 총합, 평균(소수 첫째자리까지 표시),
--사원수, 최대급여, 최소급여

SELECT ROUND(SUM(E.SAL)), ROUND(AVG(E.SAL),1)), LENGTH(E.ENAME), MAX(E.SAL), MIN(E.SAL)
FROM 
    EMP E JOIN DEPT D
    ON E.DEPTNO=D.DEPTNO
    , SALGRADE S
    WHERE E.SAL BETWEEN S.LOWSAL AND S.HISAL
ORDER BY S.GRADE;

SELECT S.GRADE G, SUM(E.SAL), ROUND(AVG(E.SAL),1), COUNT(E.SAL), MAX(E.SAL), MIN(E.SAL)
FROM EMP E, SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL
GROUP BY S.GRADE
ORDER BY S.GRADE;
--ORDER BY 1;
--ORDER BY G;

--급여가 1000이상인 사원 가운데
-- 각 급여 등급별 평균 급여가 1500이상
--급여 등급별 급여총합, 평균(소수 첫째자리까지 표시)
--사원수, 최대급여, 최소급여

SELECT SUM(SAL), AVG(SAL), COUNT(SAL), MAX(SAL), MIN(SAL)
FROM EMP E JOIN DEPT D
ON E.DEPTNO = D.DEPTNO, SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL
AND E.SAL>=1000
GROUP BY S.GRADE
HAVING AVG(S.SAL) >= 1500;

SELECT S.GRADE, SUM(E.SAL), ROUND(AVG(E.SAL),1), COUNT(E.SAL), MAX(E.SAL), MIN(E.SAL)
FROM EMP E, SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL
AND E.SAL>=1000
GROUP BY S.GRADE
HAVING AVG(E.SAL)>=1500
ORDER BY S.GRADE;

SELECT S.GRADE, SUM(E.SAL), ROUND(AVG(E.SAL),1), MAX(E.SAL),MIN(E.SAL)
FROM EMP E JOIN SALGRADE S
ON E.SAL BETWEEN S.LOSAL AND S.HISAL
AND E.SAL>=1000
GROUP BY S.GRADE
HAVING AVG(E.SAL)>=1500
ORDER BY S.GRADE;

--NATURAL JOIN
--USING(DEPTNO)생략
--ON(WHERE), E.DKEPTNO=D.DEPTNO 생략
--두 테이블 간의 동일한 이름을 갖는 모든 컬럼들에 대해 자동으로 EQUI JOIN 수행
--ON, USING 사용 불가
--공통 컬럼명이 없으면 CROSS JOIN(카테시안 곱), 모든 경우의 수
--단순한 WHERE절은 사용가능
--공통 컬럼명이 있을때에만 사용가능

SELECT *
FROM EMP E, DEPT 
WHERE E.DEPTNO=D.DEPTNO;

SELECT *
FROM EMP E NATURAL JOIN DEPT D;

SELECT *
FROM EMP E, DEPT D
WHERE E.DEPTNO=D.DEPTNO;

SELECT *
FROM EMP E NATURAL JOIN DEPT D;

SELECT *
FROM EMP E NATURAL JOIN DEPT D
ON E.DEPTNO=D.DEPTNO; --(X)

--공통 컬럼명이 없으면 CROSS JOIN(카테시안 곱), 모든 경우의 수가 나옴
SELECT *
FROM EMP E NATURAL JOIN SALGRADE S;

SELECT *
FROM EMP E NATURAL JOIN DEPT D
WHERE E.DEPTNO=D.DEPTNO; --(X)

SELECT *
FROM EMP E NATURAL JOIN DEPT D
WHERE E.SAL>=2000; --(X)

SELECT *
FROM EMP E, DEPT D WHERE E.DEPTNO=D.DEPTNO;
SELECT * FROM EMP E NATURAL JOIN DEPT D;
SELECT * FROM EMP E NATURAL JOIN DEPT D ON E.DEPTNO=D.DEPTNO; --(X)
--공통 컬럼명이 없으면 CROSS JOIN(카테시안 곱), 모든 경우의 수가 나옴
SELECT * FROM EMP E NATURAL JOIN SALGRADE S;
SELECT * FROM EMP E NATURAL JOIN DEPT D WHERE E.DEPTNO=D.DEPTNO; --(X)
SELECT * FROM EMP E NATURAL JOIN DEPT D WHERE E.SAL>=2000; --(X)

--CROSS JOIN
--JOIN 조건절이 없는 경우
--모든 경우의 수
-- WHERE 조건절 사용 가능
--ON, USING 사용 불가

SELECT *FROM EMP E CROSS JOIN DEPT D; --모든 경우의 수
SELECT *FROM EMP E, DEPT D;
SELECT *FROM EMP E CROSS JOIN DEPT D WHERE E.DEPTNO=D.DEPTNO;
SELECT *FROM EMP E CROSS JOIN DEPT D ON E.DEPTNO=D.DEPTNO; --(X)
SELECT *FROM EMP E CROSS JOIN DEPT D USING(DEPTNO); --(X)

SELECT *FROM A;
SELECT *FROM B;

SELECT *FROM A,B;
SELECT * FROM A CROSS JOIN B;
SELECT *FROM A,B WHERE A.X=B.X;
SELECT *FROM A,B WHERE A.X=B.Y;
SELECT *FROM A JOIN B ON A.X=B.Y;
SELECT *FROM A JOIN B USING(X);
SELECT *FROM A JOIN B USING(Y);

SELECT *FROM A NATURAL JOIN B;
SELECT *FROM A JOIN B USING(X);
SELECT *FROM A JOIN B USING(Y);
SELECT *FROM A JOIN B USING(X,Y);

-- 조인유형: INNER JOIN, NATURAL JOIN, CROSS JOIN, OUTER JOIN
--OUTER JOIN:LEFT OUTER JOIN, RIGHT OUTER JOIN, FULL OUTER JOIN
SELECT *
FROM A JOIN B
ON A.X=B.X;

SELECT *
FROM A JOIN B
ON B.X=A.X;

SELECT * FROM A;


SELECT *
FROM A LEFT OUTER JOIN B
ON A.X=B.X;

SELECT *
FROM A JOIN B
ON A.X=B.X(+); --LEFT OUTER JOIN과 같음

SELECT *
FROM A RIGHT OUTER JOIN B
ON A.X=B.X;

SELECT *
FROM A JOIN B
ON A.X(+)=B.X; --RIGHT OUTER JOIN과 같음

SELECT *
FROM A FULL OUTER JOIN B
ON A.X=B.X;

SELECT *
FROM A JOIN B
ON A.X(+)=B.X(+); --(X)FULL OUTER 안됨

SELECT *FROM EMP;
SELECT *FROM DEPT;

SELECT *FROM EMP E, DEPT D WHERE E.DEPTNO=D.DEPTNO;

SELECT* 
FROM EMP E RIGHT OUTER JOIN DEPT D
ON E.DEPTNO=D.DEPTNO;

--집합 연산자(테이블을 아래에 합치는 느낌?) 인스턴스 늘어남
-- UNION/UNION ALL/INTERSECT/MINUS(EXCEPT)
--1) 컬럼수가 일치(컬럼 수가 다른경우에도 사용 가능)
--2) 대응하는 컬럼 유형 일치

SELECT *FROM A,B WHERE A.X=B.X;

SELECT *FROM A
UNION ALL       --(+)
SELECT *FROM B;

SELECT *FROM B
UNION ALL       --(+)
SELECT *FROM A;

SELECT *FROM A
UNION ALL       --(+)
SELECT *FROM A;

SELECT *FROM B
UNION ALL       --(+)
SELECT *FROM B;

SELECT *FROM A
UNION               --(+) 정렬, 중복 제거, 순서와 무관
SELECT *FROM B;

SELECT *FROM B
UNION               --(+) 정렬, 중복 제거, 순서와 무관
SELECT *FROM A;

SELECT *FROM A
INTERSECT           -- 교집합, 정렬, 중복제거, 똑같은 거
SELECT *FROM B;

SELECT *FROM B
INTERSECT           -- 교집합, 정렬, 중복제거, 테이블 순서와 무관
SELECT *FROM A;

SELECT *FROM A
MINUS           -- 차집합, 정렬, 중복제거
SELECT *FROM B;

SELECT *FROM EMP
UNION ALL
SELECT *FROM DEPT; --(X) 열 맞춰줘야 함

SELECT ENAME, EMPNO, SAL FROM EMP
UNION ALL
SELECT *FROM DEPT; --(X)

SELECT ENAME, EMPNO, SAL FROM EMP
UNION ALL
SELECT DEPTNO, DNAME, LOC FROM DEPT; --(X) 자료형이 다름

SELECT EMPNO, ENAME, JOB FROM EMP
UNION ALL
SELECT DEPTNO, DNAME, LOC FROM DEPT; --(O) 자료형이 맞음

SELECT EMPNO, ENAME, JOB FROM EMP
UNION ALL
SELECT * FROM DEPT; --(O)

SELECT DEPTNO FROM EMP
MINUS
SELECT DEPTNO FROM DEPT;

--셀프조인
--하나의 테이블에서 연관 규칙이 존재할 때 사용

-- 각 사원의 ENAME, EMPNO, MGR, MGR의 ENAME
SELECT ENAME, EMPNO, MGR
FROM EMP;

SELECT *FROM EMP;

SELECT*
FROM EMP E1, EMP E2
WHERE E1.EMPNO=E2.MGR; --E1: 상사 테이블, E2: 사원 테이블

SELECT*
FROM EMP E1, EMP E2
WHERE E1.MGR=E2.EMPNO; --E1: 사원 테이블, E2: 상사 테이블

SELECT E1.ENAME, E1.EMPNO, E1.MGR, E2.ENAME
FROM EMP E1, EMP E2
WHERE E1.MGR=E2.EMPNO; 

SELECT E1.ENAME, E1.EMPNO, E1.MGR, E2.EMPNO, E2.ENAME
FROM EMP E1 JOIN EMP E2
ON E1.MGR = E2.EMPNO;

--서브쿼리

--SCOTT이 근무하고 있는 부서의 이름
SELECT * FROM EMP ;
SELECT *FROM DEPT;

SELECT D.DNAME
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
AND E.ENAME= 'SCOTT';

SELECT D.DNAME
FROM EMP E JOIN DEPT D
ON E.DEPTNO=D.DEPTNO
WHERE E.ENAME ='SCOTT';

SELECT DEPTNO FROM EMP WHERE ENAME='SCOTT';
SELECT DNAME FROM DEPT WHERE DEPTNO=20;

SELECT DNAME 
FROM DEPT 
WHERE DEPTNO=(SELECT DEPTNO 
                FROM EMP 
                WHERE ENAME='SCOTT');

SELECT EMPNO, ENAME, SAL FROM EMP;
SELECT EMPNO, ENAME, SAL, SUM(SAL) FROM EMP; --(X)
SELECT SUM(SAL) FROM EMP;
SELECT EMPNO, ENAME, SAL,(SELECT SUM(SAL) FROM EMP) FROM EMP;

--ALLEN과 같은 MGR을 가진 사원들의 EMPNO, ENAME, MGR
SELECT MGR FROM EMP WHERE ENAME='ALLEN';
SELECT EMPNO, ENAME, MGR FROM EMP WHERE MGR=7698;

SELECT EMPNO, ENAME, MGR 
FROM EMP 
WHERE MGR=(SELECT MGR FROM EMP WHERE ENAME='ALLEN');

--CHICAGO에서 근무하는 사원 중 BLAKE가 직속상관인 사원들의
--EMPNO, ENAME, JOB, DEPTNO
SELECT *FROM EMP;
SELECT *FROM DEPT;

SELECT DEPTNO FROM DEPT D WHERE D.LOC='CHICAGO';

SELECT E1.NAME(SELECT E.ENAME FROM EMP E, DEPT D WHERE D.LOC='CHICAGO')
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO AND E2.ENAME = 'BLAKE';

--SUBQUERY
SELECT EMPNO, ENAME, JOB, DEPTNO, MGR
FROM EMP
WHERE DEPTNO = (SELECT DEPTNO FROM DEPT WHERE LOC='CHICAGO')
AND
MGR=(SELECT EMPNO FROM EMP WHERE ENAME='BLAKE');

--JOIN
SELECT E.EMPNO, E.ENAME, E.JOB, E.DEPTNO
FROM EMP E JOIN DEPT D
ON E.DEPTNO = D.DEPTNO
WHERE D.LOC = 'CHICAGO'
AND MGR=(SELECT E.EMPNO FROM E.EMP WHERE E.ENAME='BLAKE');

SELECT E1.EMPNO, E1.ENAME, E1.JOB, E1.DEPTNO
FROM EMP E1, DEPT D, EMP E2
WHERE E1.DEPTNO=D.DEPTNO
AND E1.MGR=E2.EMPNO
AND D.LOC='CHICAGO'
AND E2.ENAME = 'BLAKE';