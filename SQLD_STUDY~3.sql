-- 5일차

-- 1.
-- EMP평균급여에 급여가 가까운 순서대로 오름차순 정렬
-- ENAME, EMPNO, SAL, 평균급여(소수첫째자리), 급여차이값


SELECT *FROM EMP;
SELECT ENAME, EMPNO, SAL, 
(SELECT ROUND(AVG(SAL),1) FROM EMP) AVG,
SAL-(SELECT ROUND(AVG(SAL),1) FROM EMP) GAP,
ABS(SAL-(SELECT ROUND(AVG(SAL),1) FROM EMP)) ABS
FROM EMP 
--ORDER BY 6;
ORDER BY ABS;
--ORDER BY ABS(SAL-(SELECT ROUND(AVG(SAL),1) FROM EMP));


--2.
-- 전직원 평균급여보다 급여가 높은 사원 EMPNO, ENAME, SAL, 평균급여(전직원)
SELECT EMPNO, ENAME, SAL,(SELECT ROUND(AVG(SAL),1) FROM EMP) AVG
FROM EMP 
WHERE SAL > (SELECT ROUND(AVG(SAL),1) FROM EMP);

SELECT EMPNO, ENAME, SAL,(SELECT ROUND(AVG(SAL),1) FROM EMP) AVG
FROM EMP 
WHERE SAL > AVG; --(X)

SELECT EMPNO, ENAME, SAL,(SELECT ROUND(AVG(SAL),1) FROM EMP)
FROM EMP 
WHERE SAL > (SELECT ROUND(AVG(SAL),1) FROM EMP);

--P.184
--다중행 비교연산자 : IN,ALL,ANY, EXISTS

--SAL 3000이상인 사원들과 같은 부서에 근무하는 사원 EMPNO, ENAME, SAL, DEPTNO

SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE DEPTNO=(SELECT DEPTNO FROM EMP WHERE SAL>=3000); --결과가 2개라서 = 조건 만족이 안됨
SELECT DEPTNO FROM EMP WHERE SAL>=3000;

SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE DEPTNO=(SELECT DEPTNO FROM EMP WHERE SAL>=5000); --결과가 1개일 때는 가능

SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE DEPTNO=(SELECT DEPTNO FROM EMP WHERE SAL>=6000); 

--결과가 2명이상일 때
--IN(OR,단일, 다중행 모두 사용 가능)

SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE DEPTNO IN (SELECT DEPTNO FROM EMP WHERE SAL>=3000); 
--IN(20,10,20)-->20 OR 10 OR 20

--IN(10)->10
--ALL(AND,단일,다중행 모두 사용 가능)
--ALL앞에 연산자 들어감
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE DEPTNO = ALL (SELECT DEPTNO FROM EMP WHERE SAL>=3000); 
--ALL(20,10,20) -> 20 AND 10 AND 20 -> NULL 실험결과가 안나옴

SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE DEPTNO > ALL (SELECT DEPTNO FROM EMP WHERE SAL>=3000); 
--ALL(20,10,20) -> >20 AND >10 AND >20 -> 30 AND(20,30) AND 30 -> 30
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE DEPTNO <= ALL (SELECT DEPTNO FROM EMP WHERE SAL>=3000); 
--ALL(20,10,20) -> <=20 AND <=10 AND <=20 -> (10,20) AND (10) AND (10,20) -> 10

--ANY(OR, 단일, 다중행 모두 사용 가능)
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE DEPTNO = ANY(SELECT DEPTNO FROM EMP WHERE SAL>=3000); 
-- ANY(20,10,20) -> 20 OR 10 OR 20 -> 10 OR 20

SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE DEPTNO >= ALL (SELECT DEPTNO FROM EMP WHERE SAL>=3000); 
--ANY(20,10,20) -> >=20 OR >=10 OR >=20 -> (20,30) OR (10,20,30) OR (20,30) -> 10,20,30

--EXISTS(존재여부, 참, 거짓 판단, 단일, 다중행 모두 사용 가능)
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE DEPTNO >EXISTS(SELECT DEPTNO FROM EMP WHERE SAL>=3000); 
--(X)

SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE EXISTS(SELECT DEPTNO FROM EMP WHERE SAL>=3000); 
--
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE EXISTS(SELECT DEPTNO FROM EMP WHERE SAL>=6000); 
--
SELECT *FROM EMP WHERE 1=1;
SELECT *FROM EMP WHERE 1=2;
SELECT *FROM EMP;
SELECT *FROM DEPT;

--DALLAS에 근무하는 어떤 사원들의 입시일보다 빨리 입사한 사원들의 EMPNO, ENAME, HIREDATE
SELECT EMPNO, ENAME, HIREDATE
FROM EMP
WHERE HIREDATE < ANY(SELECT HIREDATE 
                    FROM EMP 
                    WHERE DEPTNO = (SELECT DEPT.DEPTNO 
                                    FROM DEPT 
                                    WHERE LOC = 'DALLAS'));

SELECT EMPNO, ENAME, HIREDATE
FROM EMP
WHERE HIREDATE < ANY(SELECT E.HIREDATE 
                    FROM EMP E, DEPT D 
                    WHERE E.DEPTNO=D.DEPTNO
                    AND D.LOC = 'DALLAS');

-- P.187 다중 컬럼 서브쿼리

--FORD와 MGR, DEPTNO가 같은 사원 EMPNO, ENAME, MGR, DEPTNO
SELECT EMPNO, ENAME, MGR, DEPTNO
FROM EMP
WHERE MGR = (SELECT MGR
            FROM EMP
            WHERE ENAME = 'FORD')
AND DEPTNO = (SELECT DEPTNO
            FROM EMP
            WHERE ENAME='FORD');
            
--다중행
SELECT EMPNO, ENAME, MGR, DEPTNO
FROM EMP
WHERE MGR IN (SELECT MGR
            FROM EMP
            WHERE ENAME = 'FORD')
AND DEPTNO IN (SELECT DEPTNO
            FROM EMP
            WHERE ENAME='FORD');

SELECT EMPNO, ENAME, MGR, DEPTNO
FROM EMP
WHERE MGR,DEPTNO IN (SELECT MGR, DEPTNO
            FROM EMP
            WHERE ENAME = 'FORD'); --(X) 관계 연산자 부적합
            
SELECT EMPNO, ENAME, MGR, DEPTNO
FROM EMP
WHERE (MGR,DEPTNO) IN (SELECT MGR, DEPTNO
            FROM EMP
            WHERE ENAME = 'FORD');  --다중행 괄호 안에 넣어주기
            
--인라인 뷰
--FROM절에 위치하는 서브쿼리

SELECT *FROM EMP ;
SELECT *FROM EMP WHERE ROWNUM=1;
SELECT *FROM EMP WHERE ROWNUM=2;
SELECT *FROM EMP WHERE ROWNUM<=2;
SELECT ROWNUM, EMPNO, ENAME, SAL FROM EMP;

SELECT *FROM (SELECT ROWNUM, EMPNO, ENAME, SAL FROM EMP); --INLINE VIEW

SELECT *
FROM (SELECT ROWNUM, EMPNO, ENAME, SAL FROM EMP)
WHERE ROWNUM =1;

SELECT *
FROM (SELECT ROWNUM, EMPNO, ENAME, SAL FROM EMP)
WHERE ROWNUM =2; --ROWNUM=2 결과 안나옴

--INLINE VIEW 적용
--별칭 이용
SELECT *
FROM (SELECT ROWNUM R, EMPNO, ENAME, SAL FROM EMP)
WHERE R =2; 

-- TOP N 쿼리

SELECT EMPNO, SAL
FROM EMP
ORDER BY SAL
FETCH FIRST 5 ROWS ONLY; --앞에서부터 5개

SELECT EMPNO, SAL
FROM EMP
ORDER BY SAL, EMPNO DESC
FETCH FIRST 5 ROWS ONLY; 

SELECT EMPNO, SAL
FROM EMP
ORDER BY SAL, EMPNO DESC
OFFSET 5 ROWS; --상위 5개 제외

--계층형 질의(조희)
SELECT *FROM EMP;

--순방향, 역방향, ROOT, LEAF
--순방향: 부모 -> 자식, 상사->사원, ROOT->LEAF
--역방향: 자식->부모, 사원->상사, LEAF->ROOT

SELECT ENAME, EMPNO, MGR, LEVEL
FROM EMP
START WITH MGR IS NULL --시작위치
CONNECT BY EMPNO=PRIOR MGR; --순방향, 역방향 결정

--PRIOR EMPNO = MGR
--PRIOR (OF) EMPNO = MGR
--상사 OF 사원 = 상사
--사원의 상사 = 상사 --> 순방향

--EMPNO = PRIOR MGR
--EMPNO =PRIOR (OF) MGR
--사원 = 상사 OF 상사
--사원 = 상사의 상사 --> 역방향(말이 안됨)

SELECT ENAME, EMPNO, MGR, LEVEL
FROM EMP
START WITH MGR IS NULL --시작위치
CONNECT BY EMPNO=PRIOR MGR; --역방향

SELECT ENAME, EMPNO, MGR, LEVEL
FROM EMP
START WITH MGR IS NULL --시작위치
CONNECT BY PRIOR EMPNO= MGR; --순방향

SELECT *FROM EMP;

SELECT *FROM EMP;

SELECT ENAME, EMPNO, MGR, LEVEL
FROM EMP
START WITH MGR =7902--시작위치
CONNECT BY EMPNO=PRIOR MGR; --역방향

SELECT ENAME, EMPNO, MGR, SAL, LEVEL
FROM EMP
WHERE SAL!= 3000 --중간에 WHERE절을 사용하면 순방향 랭크 중 해당사항
START WITH MGR = 7902 --시작위치
CONNECT BY EMPNO=PRIOR MGR; --순방향

--계층형일 경우
SELECT ENAME, EMPNO, MGR, SAL, LEVEL
FROM EMP
START WITH MGR = 7902 --시작위치
CONNECT BY EMPNO=PRIOR MGR --순방향
AND SAL!=3000; --WHERE 대신 CONNECT BY 뒤에 조건 사용하면 맞는 조건항 뒤에는 실행 안됨

SELECT ENAME, EMPNO, MGR, LEVEL
FROM EMP
WHERE LEVEL<=2
START WITH MGR IS NULL --시작위치
CONNECT BY PRIOR EMPNO= MGR;

SELECT ENAME, EMPNO, MGR, LEVEL
FROM EMP
START WITH MGR IS NULL --시작위치
CONNECT BY PRIOR EMPNO= MGR;

SELECT ENAME, EMPNO, MGR, LEVEL
FROM EMP
START WITH MGR IS NULL --시작위치
CONNECT BY PRIOR EMPNO= MGR
ORDER SIBLINGS BY EMPNO; --형제노드에서 EMPNO 내림차순

SELECT ENAME, EMPNO, MGR, LEVEL
FROM EMP
--WHERE LEVEL<=2
START WITH MGR IS NULL --시작위치
CONNECT BY PRIOR EMPNO= MGR
ORDER SIBLINGS BY EMPNO DESC;  --SIBLINGS:형제 노드 내에서 순서 결정

--P190 그룹함수
--ROLLUP, GROUPIG SETS, CUBE

SELECT *FROM EMP;
SELECT DEPTNO, SUM(SAL) FROM EMP GROUP BY DEPTNO ORDER BY DEPTNO;

SELECT DEPTNO, SUM(SAL)
FROM EMP
GROUP BY DEPTNO
ORDER BY DEPTNO; --GROUP BY DEPTNO -> GROUP BY A

SELECT NULL, SUM(SAL)
FROM EMP
GROUP BY NULL; --GROUP BY NULL : 전체

SELECT DEPTNO, SUM(SAL)
FROM EMP
GROUP BY DEPTNO
UNION ALL --합치기
SELECT NULL, SUM(SAL)
FROM EMP
GROUP BY NULL --GROUP BY NULL : 전체
ORDER BY DEPTNO; --ORDER BY는 마지막에!!

SELECT DEPTNO, JOB, SUM(SAL)
FROM EMP
GROUP BY JOB, DEPTNO --GROUP BY JOB, DEPTNO = GROUP BY A,B
ORDER BY JOB, DEPTNO; 

SELECT DEPTNO, JOB, SUM(SAL)
FROM EMP
GROUP BY DEPTNO, JOB
ORDER BY DEPTNO, JOB; --GROUP BY DEPTNO, JOB -> GROUP BY JOB, DEPTNO 

SELECT DEPTNO, SUM(SAL)
FROM EMP
GROUP BY ROLLUP (DEPTNO);

SELECT DEPTNO, SUM(SAL)
FROM EMP
GROUP BY(DEPTNO);

SELECT DEPTNO, SUM(SAL)
FROM EMP
GROUP BY GROUPING SETS (DEPTNO);

SELECT DEPTNO, SUM(SAL)
FROM EMP
GROUP BY CUBE (DEPTNO);

--인수가 1개일때

--ROLLUP
--GROUP BY A
--(UNION ALL)
--GROUP BY NULL

--GROUPING SETS
--GROUP BY A

--CUBE = ROLLUP
--GROUP BY A
--GROUP BY NULL

SELECT DEPTNO, JOB, SUM(SAL)
FROM EMP
GROUP BY DEPTNO, JOB
ORDER BY DEPTNO, JOB;

SELECT DEPTNO, JOB, SUM(SAL)
FROM EMP
GROUP BY ROLLUP(DEPTNO, JOB);

SELECT DEPTNO, JOB, SUM(SAL)
FROM EMP
GROUP BY GROUPING SETS(DEPTNO, JOB);

SELECT DEPTNO, JOB, SUM(SAL)
FROM EMP
GROUP BY CUBE(DEPTNO, JOB);

--인수가 2개일때

--ROLLUP(A,B)
--GROUP BY A
--GROUP BY A, B(GROUP BY B,A)
--GROUP BY NULL

--GROUPING SETS(A,B)
--GROUP BY A
--GROUP BY B

--CUBE 
--GROUP BY A
--GROUP BY B
--GROUP BY A,B(B,A)
--GROUP BY NULL

--실행 결과 수 : CUBE>=ROLLUP>GROUPING SETS
--인수의 순서와 무관한 함수 : GROUPING SETS, CUBE

--GROUPING SETS를 이용해서 ROLLUP, CUBE 표현
--ROLLUP
SELECT DEPTNO, JOB, SUM(SAL)
FROM EMP
GROUP BY ROLLUP(DEPTNO, JOB);

SELECT DEPTNO, JOB, SUM(SAL)
FROM EMP
GROUP BY GROUPING SETS(DEPTNO,(DEPTNO, JOB),NULL);

SELECT DEPTNO, JOB, SUM(SAL)
FROM EMP
GROUP BY GROUPING SETS(DEPTNO,(DEPTNO, JOB),());
--CUBE
SELECT DEPTNO, JOB, SUM(SAL)
FROM EMP
GROUP BY CUBE(DEPTNO, JOB);

SELECT DEPTNO, JOB, SUM(SAL)
FROM EMP
GROUP BY GROUPING SETS(NULL,JOB, DEPTNO, (JOB,DEPTNO));

-- P.201 윈도우 함수

--SELECT 컬럼명1, 컬럼명2,...,
--WINDOW_FUNCTION()OVER()
--FROM 테이블명;

--<> -> 의미는 있을 수 도 있고, 없을 수도 있음
--윈도우 함수: 순위, 집계, 행 순서, 비율
--WINDOW_FUNCTION(<인수>)OVER(<PARTITION BY 컬럼명> <PARTITION BY 컬럼명> <ORDER BY 절> <WINDOWING 절>)
--FROM 테이블명;

--PARTITION BY: GROUP BY 개념

--순위관련함수
--RANK, DENSE_RANK, ROW_NUMBER

--RANK 함수
--동순위 유무에 따라 결과가 달라짐
--동순위가 없다면 3가지 결과가 모두 동일
--OVER(ORDER BY 절) 필수
--인수 불 필요
--PARTITION BY : GROUP BY 역할

SELECT EMPNO, ENAME, SAL,
RANK()OVER(ORDER BY SAL DESC) RANK,
DENSE_RANK()OVER(ORDER BY SAL DESC) RANK,
ROW_NUMBER()OVER(ORDER BY SAL DESC) ROW_NUMBER
FROM EMP;

SELECT EMPNO, ENAME, SAL, DEPTNO,
RANK()OVER(ORDER BY SAL DESC) RANK0,
RANK()OVER(PARTITION BY DEPTNO ORDER BY SAL DESC) RANK2
--RANK(1)OVER(ORDER BY SAL DESC) RANK, --인수 필요없음
FROM EMP
ORDER BY DEPTNO;

--집계관련함수
--SUM, AVG, COUNT, MAX, MIN
--인수 필수
--OVER(ORDER BY 절) : 누적 합계

SELECT EMPNO, ENAME, SAL, 
SUM(SAL)OVER()
FROM EMP;

SELECT EMPNO, ENAME, SAL, SUM(SAL) FROM EMP; --(X)
SELECT EMPNO, ENAME, SAL, SUM(SAL)OVER() FROM EMP;
SELECT EMPNO, ENAME, SAL, (SELECT SUM(SAL) FROM EMP) FROM EMP;

SELECT EMPNO, ENAME, SAL, DEPTNO,
SUM(SAL)OVER() SUM0,
SUM(SAL)OVER(ORDER BY SAL) SUM1, --누적합계
SUM(SAL)OVER(PARTITION BY DEPTNO) SUM2, --부서별 합계
SUM(SAL)OVER(PARTITION BY DEPTNO ORDER BY SAL) SUM3 --부서별 누적 합계
FROM EMP
ORDER BY DEPTNO;

SELECT COUNT(*), COUNT(EMPNO), COUNT(COMM), COUNT(1) FROM EMP;
SELECT 1 FROM EMP;
SELECT EMPNO FROM EMP;

--행 순서 관련 함수
--FIRST_VALUE, LAST_VALUE, LAG, LEAD

SELECT EMPNO, ENAME, SAL, DEPTNO,
FIRST_VALUE(SAL)OVER() FIRST1,
FIRST_VALUE(ENAME)OVER() FIRST2,
FIRST_VALUE(ENAME)OVER(ORDER BY SAL) FIRST3,
FIRST_VALUE(ENAME)OVER(PARTITION BY DEPTNO ORDER BY SAL) FIRST4
FROM EMP
ORDER BY DEPTNO;

SELECT EMPNO, ENAME, SAL, DEPTNO,
LAST_VALUE(SAL)OVER() LAST1,
LAST_VALUE(ENAME)OVER() LAST2,
LAST_VALUE(ENAME)OVER(ORDER BY SAL) LAST3,
LAST_VALUE(ENAME)OVER(PARTITION BY DEPTNO ORDER BY SAL) LAST4
FROM EMP
ORDER BY DEPTNO;

--LAG : 이전행(앞행)을 가져온다
--OVER(ORDER BY 절)필수
--인수 필수
SELECT EMPNO, ENAME, SAL, DEPTNO,
LAG(SAL)OVER(ORDER BY SAL) LAG1,
LAG(ENAME)OVER(ORDER BY SAL) LAG2,
LAG(ENAME)OVER(PARTITION BY DEPTNO ORDER BY SAL) LAG3
FROM EMP
ORDER BY DEPTNO;

SELECT EMPNO, ENAME, SAL, 
LAG(SAL,0)OVER(ORDER BY SAL) LAG1,
LAG(SAL)OVER(ORDER BY SAL) LAG2,
LAG(SAL,1)OVER(ORDER BY SAL) LAG3,
LAG(SAL,2)OVER(ORDER BY SAL) LAG4
FROM EMP;

--LEAD
--LEAD : 다음 행(뒷 행)을 가져온다
--OVER(ORDER BY 절)필수
--인수 필수

SELECT EMPNO, ENAME, SAL, 
LEAD(SAL,0)OVER(ORDER BY SAL) LEAD1,
LEAD(SAL)OVER(ORDER BY SAL) LEAD2,
LEAD(SAL,1)OVER(ORDER BY SAL) LEAD3,
LEAD(SAL,2)OVER(ORDER BY SAL) LEAD4
FROM EMP;

--비율 관련 함수
-- CUME_DIST, RATIO_REPORT, PERCENT_RANK, NTILE

--CUME_DIST:순위가 0~1사이 값을 %로 표시
--4개인 경우: 0.25,0.5,0.75
--RATIO_REPORT : 값이 0~1 어느 위치인지 파악(전체 급여에서 본인 급여의 비중)

--NTILE
--N등분

--급여를 기준으로 4개의 소그룹으로 분류

SELECT EMPNO, ENAME, SAL FROM EMP ORDER BY SAL;
SELECT EMPNO, ENAME, SAL, DEPTNO,
NTILE(4)OVER(ORDER BY SAL) NTILE1,
NTILE(4)OVER(PARTITION BY DEPTNO ORDER BY SAL) NTILE2 -- 부서별(PARTITION BY)로 나뉘어짐
FROM EMP
ORDER BY DEPTNO;

--WINDOW_FUNCTION(<인수>)OVER(<PARTITION BY 컬럼명> <PARTITION BY 컬럼명> <ORDER BY 절> <WINDOWING 절>)
--FROM 테이블명;

--PRECEDING:이전행
--FOLLOWING:다음행
--UNBOUNDED PRECEDING : 시작위치가 첫번째 행부터, 처음부터
--UNBOUNDED FOLLOWING : 마지막 위치가 마지막행, ~ 마지막까지
--CURRENT ROW: 현재행
--ROWS : 행수
--RANGE : 값의 범위

--급여 오름차순 정렬
--현재 행 기분으로 앞, 뒤 1행의 합

SELECT EMPNO, ENAME,
LAG(SAL)OVER(ORDER BY SAL)LAG,
SAL,
LEAD(SAL)OVER(ORDER BY SAL) LEAD,
SUM(SAL)OVER(ORDER BY SAL) SUM, --누적합계
SUM(SAL)OVER(ORDER BY SAL ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) SUM1, --  ROWS 지정 ,BETWEEN으로 하나 앞에서 하나 뒤까지
SUM(SAL)OVER(ORDER BY SAL ROWS BETWEEN 2 PRECEDING AND 4 FOLLOWING) SUM2,
SUM(SAL)OVER(ORDER BY SAL ROWS BETWEEN UNBOUNDED PRECEDING AND 1 FOLLOWING) SUM3,--UNBOUNDED 는 처음부터
SUM(SAL)OVER(ORDER BY SAL ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SUM4, --전체 합계 
SUM(SAL)OVER(ORDER BY SAL ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) SUM5, --전체 합계 
SUM(SAL)OVER(ORDER BY SAL ROWS UNBOUNDED PRECEDING) SUM7,
--SUM(SAL)OVER(ORDER BY SAL ROWS UNBOUNDED FOLLOWING) SUM7, --(X)
SUM(SAL)OVER(ORDER BY SAL ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) SUM6 --전체 합계 
FROM EMP;

--RANGE : 값의 범위
--범위가 RANGE냐 ROWS인지 잘 봐야함

SELECT EMPNO, ENAME, SAL,
SUM(SAL)OVER(ORDER BY SAL RANGE BETWEEN 1 PRECEDING AND 1 FOLLOWING) SUM1, --800~801, 949~951,...
SUM(SAL)OVER(ORDER BY SAL RANGE BETWEEN 100 PRECEDING AND 200 FOLLOWING) SUM2 --700~1000, 850~1150,...
FROM EMP;

--PIVOT, UNPIBOT
SELECT*
FROM(SELECT JOB, DEPTNO, SAL FROM EMP)
PIVOT (SUM(SAL) FOR DEPTNO IN(10,20,30)); --UNPIVOT하면 원상태로 돌아감

SELECT *
FROM(SELECT TO_CHAR(HIREDATE,'YYYY') YYYY, JOB, DEPTNO, SAL FROM EMP)
PIVOT (SUM(SAL) FOR DEPTNO IN(10,20,30));

SELECT UPPER('ebac') FROM DUAL;
SELECT RTRIM('EBAC') FROM DUAL;
SELECT SUBSTR('ABCEBACED',4,4) FROM DUAL;
SELECT CONCAT('EB','AC') FROM DUAL;

CREATE TABLE TAB1 (C1 NUMBER(10), C2 NUMBER(10), C VARCHAR2(10));
INSERT INTO TAB1 VALUES(1,'',A);
